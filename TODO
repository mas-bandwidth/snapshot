DONE

	Fix payload packet issue with loopback. For example, we don't really want to encrypt/decrypt with loopback...

	Setup client so it processes payload packets from the server.

	Bring back endpoint tests with updates for the new functions.

	test_acks is breaking. Acks aren't working. There's something not right in ack processing since the refactor.

	Dig in...

	Just missing some code in the refactor, fixed.

	test_acks_packet_loss is working. Acks are done!

	There is a crash in the test_acks test.

	It's release only in MacOS, and seems to reproduce on windows only.

	Most likely some sort of stack trashing... ?

	Let's fix it.

	Payload packet needed to be expanded on stack for prefix.

	Now windows is failing (debug and release) with receiver payload bytes != 8. 

	Print out what it is so I can work out what's going on... I guess zero?

	Fixed. There was a sizeof on a pointer that used to be a fixed array.

	Get the payload test working. I suspect there is a slight mismatch on the payload bytes for fragmented packets. Seems like we're not removing the payload header on the first bytes?

	There is a still a mismatch on payload byte delivery in fragmented case, but the non-fragmented case is verified working.

	Debug fragment header mismatch.

	Changed "mark_payload_processed" to "mark_packet_processed". When fragment comes in, it has no payload, but we still need to process acks!!!

	So acks/sequence/ack_bits are at the packet level, not the payload level.

	Looks like fragmentation packet data isn't exactly matching yet, but the size is correct.

	The fragment header is mixed up everywhere.

	The idea is generally, to include the packet header in with each fragment sent, even though it's only really needed on one.

	I should adjust how the fragment header is written to make sure it's simpler... right now it's mismatching on read/write.

	Fixed. I just had some bad logic on read, based on my incorrect assumption on how my old code worked.

TODO

	Clean up. All tests pass now...

	-------------

	Add back #define SNAPSHOT_DEVELOPMENT 1 into premake file

	Wrap the network simulator stuff with #if SNAPSHOT_DEVELOPMENT

	Add some new client and server flags, for the "VALIDATE_PAYLOAD"

	Create some tests where these flags get turned on, wrapped with #if SNAPSHOT_DEVELOPMENT

	Make sure tests are wrapped with #if SNAPSHOT_DEVELOPMENT

	-------------

	Extend client and server to generate range of valid payload packet sizes, with contents that are fully verifiable (using new functions in snapshot_packets.h)

	Verify payload received on client.

	Verify payload received on server.

	-------------

	Implement a test for payload packets, ipv4, ipv6 and loopback.

	-------------



























	=========================

	Download UE5.

	Setup a snapshot UE5 plugin based on the network next UE4 plugin.

	Verify client and server can connect and operate in testbed.

	-------------

	Update to latest PS4/PS5 tooling

	Update to latest XBox Series X and GDK tooling

	Get series x testbed working

	Update to latest Nintendo Switch tooling

	-------------

	Setup additional PCs as build farm for sem

	-------------

	*** FIRST MILESTONE: SnapshotNetDriver in UE5, working on PC and PS5 ***

	-------------

	Now think what are the essential other things?

	A reliable-ordered channel with messages, bidirectional between client and server. For sure.

	The same command channel with in-line large blocks of data sent down (eg. snapshot baselines...)

	Unreliable messages stuck at the back of the packets (when there is room) for sound effects, visual fx etc...

	Player commands with input and dt sent redundantly all unacked.

	Choke.

	*** SECOND MILESTONE: Low-level protocol is complete ***

	---------------------------

	Schema

	What sort of properties are needed?

	Send delta compressed snapshots down.

	Decompress snapshot deltas on client.

	Drive object creates and deletes.

	---------------------------

	Slothy input:

		1. Uncompressed snapshots probably won't work, players are remote working not LAN

		2. Concerns around disruptive integration, how exactly does it integrate?

		3. How do we tell when object properties have changed? <----- call function when changed?

		4. Separation of client/server instances of engine objects seems like a heavy lift

		5. How do UE5 objects work?

	---------------------------
